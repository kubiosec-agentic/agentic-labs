#!/usr/bin/env python3
"""
LangGraph Fundamentals: Job Application Workflow
This demonstrates key LangGraph concepts including:
- Basic graph creation with StateGraph
- Conditional edges and routing
- State management with different reducer patterns
- Graph configuration and customization

Generated by Copilot
"""

import os
from typing import TypedDict, Literal, Annotated, Optional, Union
from operator import add
from langchain_core.runnables.config import RunnableConfig
from langgraph.graph import StateGraph, START, END


def set_environment():
    """Set up environment variables"""
    # You may need to set these environment variables for your specific setup
    # os.environ["OPENAI_API_KEY"] = "your-openai-api-key"
    # os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "path-to-credentials"
    pass


# Example 1: Basic Job Application State (Default Reducer - Replace)
class JobApplicationStateBasic(TypedDict):
    job_description: str
    is_suitable: bool
    application: str


def analyze_job_description_basic(state):
    """Analyze job description - basic version"""
    print("...Analyzing a provided job description ...")
    return {"is_suitable": len(state["job_description"]) > 100}


def generate_application_basic(state):
    """Generate application - basic version"""
    print("...generating application...")
    return {"application": "some_fake_application"}


def is_suitable_condition(state: JobApplicationStateBasic) -> Literal["generate_application", "__end__"]:
    """Conditional routing based on job suitability"""
    if state.get("is_suitable"):
        return "generate_application"
    return END


def create_basic_graph():
    """Create a basic job application graph"""
    builder = StateGraph(JobApplicationStateBasic)
    builder.add_node("analyze_job_description", analyze_job_description_basic)
    builder.add_node("generate_application", generate_application_basic)
    
    builder.add_edge(START, "analyze_job_description")
    builder.add_conditional_edges("analyze_job_description", is_suitable_condition)
    builder.add_edge("generate_application", END)
    
    return builder.compile()


# Example 2: Job Application State with Actions (Add Reducer)
class JobApplicationStateWithActions(TypedDict):
    job_description: str
    is_suitable: bool
    application: str
    actions: Annotated[list[str], add]  # Using add reducer to accumulate actions


def analyze_job_description_with_actions(state):
    """Analyze job description and track actions"""
    print("...Analyzing a provided job description ...")
    result = {
        "is_suitable": len(state["job_description"]) < 100,
        "actions": ["action1"]
    }
    return result


def generate_application_with_actions(state):
    """Generate application and track actions"""
    print("...generating application...")
    return {"application": "some_fake_application", "actions": ["action2"]}


def is_suitable_condition_actions(state: JobApplicationStateWithActions) -> Literal["generate_application", "__end__"]:
    """Conditional routing for actions version"""
    if state.get("is_suitable"):
        return "generate_application"
    return END


def create_actions_graph():
    """Create job application graph with action tracking"""
    builder = StateGraph(JobApplicationStateWithActions)
    builder.add_node("analyze_job_description", analyze_job_description_with_actions)
    builder.add_node("generate_application", generate_application_with_actions)
    
    builder.add_edge(START, "analyze_job_description")
    builder.add_conditional_edges("analyze_job_description", is_suitable_condition_actions)
    builder.add_edge("generate_application", END)
    
    return builder.compile()


# Example 3: Custom Reducer for More Control
def my_reducer(left: list[str], right: Optional[Union[str, list[str]]]) -> list[str]:
    """Custom reducer that can handle both strings and lists"""
    if right:
        return left + [right] if isinstance(right, str) else left + right
    return left


class JobApplicationStateCustom(TypedDict):
    job_description: str
    is_suitable: bool
    application: str
    actions: Annotated[list[str], my_reducer]  # Using custom reducer


def analyze_job_description_custom(state):
    """Analyze job description with custom action tracking"""
    print("...Analyzing a provided job description ...")
    result = {
        "is_suitable": len(state["job_description"]) < 100,
        "actions": "action1"  # Single string
    }
    return result


def generate_application_custom(state):
    """Generate application with multiple actions"""
    print("...generating application...")
    return {"application": "some_fake_application", "actions": ["action2", "action3"]}


def is_suitable_condition_custom(state: JobApplicationStateCustom) -> Literal["generate_application", "__end__"]:
    """Conditional routing for custom version"""
    if state.get("is_suitable"):
        return "generate_application"
    return END


def create_custom_graph():
    """Create job application graph with custom reducer"""
    builder = StateGraph(JobApplicationStateCustom)
    builder.add_node("analyze_job_description", analyze_job_description_custom)
    builder.add_node("generate_application", generate_application_custom)
    
    builder.add_edge(START, "analyze_job_description")
    builder.add_conditional_edges("analyze_job_description", is_suitable_condition_custom)
    builder.add_edge("generate_application", END)
    
    return builder.compile()


# Example 4: Graph with Configuration
def generate_application_configurable(state: JobApplicationStateCustom, config: RunnableConfig):
    """Generate application with configurable model settings"""
    model_provider = config["configurable"].get("model_provider", "Google")
    model_name = config["configurable"].get("model_name", "gemini-2.0-flash")
    print(f"...generating application with {model_provider} and {model_name} ...")
    return {"application": "some_fake_application", "actions": ["action2", "action3"]}


def create_configurable_graph():
    """Create job application graph with configuration support"""
    builder = StateGraph(JobApplicationStateCustom)
    builder.add_node("analyze_job_description", analyze_job_description_custom)
    builder.add_node("generate_application", generate_application_configurable)
    
    builder.add_edge(START, "analyze_job_description")
    builder.add_conditional_edges("analyze_job_description", is_suitable_condition_custom)
    builder.add_edge("generate_application", END)
    
    return builder.compile()


def save_graph_visualization(graph, filename="graph_diagram.png"):
    """Save graph visualization to file"""
    try:
        mermaid_png = graph.get_graph().draw_mermaid_png()
        with open(filename, "wb") as f:
            f.write(mermaid_png)
        print(f"Graph visualization saved to {filename}")
    except Exception as e:
        print(f"Could not save visualization: {e}")


def demonstrate_basic_workflow():
    """Demonstrate basic job application workflow"""
    print("=== Basic Job Application Workflow ===")
    graph = create_basic_graph()
    
    # Test with short job description (not suitable)
    result = graph.invoke({"job_description": "fake_jd"})
    print(f"Short job description result: {result}")
    print()
    
    # Test with long job description (suitable)
    long_description = "This is a detailed job description that contains more than 100 characters to trigger the suitable condition and proceed with application generation."
    result = graph.invoke({"job_description": long_description})
    print(f"Long job description result: {result}")
    print()


def demonstrate_actions_workflow():
    """Demonstrate workflow with action tracking"""
    print("=== Job Application Workflow with Actions ===")
    graph = create_actions_graph()
    
    result = graph.invoke({"job_description": "fake_jd"})
    print(f"Actions workflow result: {result}")
    print(f"Actions tracked: {result.get('actions', [])}")
    print()


def demonstrate_custom_reducer():
    """Demonstrate custom reducer functionality"""
    print("=== Job Application Workflow with Custom Reducer ===")
    graph = create_custom_graph()
    
    result = graph.invoke({"job_description": "fake_jd"})
    print(f"Custom reducer result: {result}")
    print(f"Actions with custom reducer: {result.get('actions', [])}")
    print()


def demonstrate_configuration():
    """Demonstrate graph configuration"""
    print("=== Configurable Job Application Workflow ===")
    graph = create_configurable_graph()
    
    # Default configuration
    result = graph.invoke({"job_description": "fake_jd"})
    print(f"Default config result: {result}")
    print()
    
    # Custom configuration
    config = {"configurable": {"model_provider": "OpenAI", "model_name": "gpt-4o"}}
    result = graph.invoke({"job_description": "fake_jd"}, config=config)
    print(f"Custom config result: {result}")
    print()


async def demonstrate_streaming():
    """Demonstrate streaming execution"""
    print("=== Streaming Job Application Workflow ===")
    graph = create_actions_graph()
    
    print("Streaming execution:")
    async for chunk in graph.astream(
        input={"job_description": "fake_jd"},
        stream_mode="values"
    ):
        print(f"Chunk: {chunk}")
        print()


def main():
    """Main execution function"""
    set_environment()
    
    print("LangGraph Fundamentals: Job Application Workflow")
    print("=" * 50)
    print()
    
    # Demonstrate different workflow patterns
    demonstrate_basic_workflow()
    demonstrate_actions_workflow()
    demonstrate_custom_reducer()
    demonstrate_configuration()
    
    # Save graph visualizations
    print("=== Saving Graph Visualizations ===")
    try:
        basic_graph = create_basic_graph()
        save_graph_visualization(basic_graph, "basic_workflow.png")
        
        actions_graph = create_actions_graph()
        save_graph_visualization(actions_graph, "actions_workflow.png")
        
        custom_graph = create_custom_graph()
        save_graph_visualization(custom_graph, "custom_reducer_workflow.png")
        
        config_graph = create_configurable_graph()
        save_graph_visualization(config_graph, "configurable_workflow.png")
    except Exception as e:
        print(f"Visualization saving failed: {e}")
    
    print("\n=== Key Concepts Demonstrated ===")
    print("1. Basic StateGraph creation and execution")
    print("2. Conditional edges for workflow routing")
    print("3. State management with different reducers:")
    print("   - Default reducer (replace values)")
    print("   - Add reducer (accumulate lists)")
    print("   - Custom reducer (flexible handling)")
    print("4. Graph configuration for runtime customization")
    print("5. Streaming execution for real-time updates")
    
    # Note about async streaming
    print("\nNote: To see streaming demonstration, run:")
    print("import asyncio")
    print("asyncio.run(demonstrate_streaming())")


if __name__ == "__main__":
    main()