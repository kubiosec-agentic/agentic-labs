#!/usr/bin/env python3
import os
import json
import subprocess
import logging
import datetime
from openai import OpenAI

# Generated by Copilot

def setup_logging():
    """Set up logging for kubectl command auditing"""
    # Create logs directory if it doesn't exist
    log_dir = "kubectl_audit_logs"
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # Set up logging with timestamp in filename
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"{log_dir}/kubectl_audit_{timestamp}.log"
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_filename),
            logging.StreamHandler()  # Also log to console
        ]
    )
    
    logger = logging.getLogger(__name__)
    logger.info(f"=== Starting Kubernetes Assistant Session ===")
    logger.info(f"Log file: {log_filename}")
    
    return logger

def log_kubectl_command(logger, cmd, namespace=None, function_name=None, success=True, error_msg=None):
    """Log kubectl command execution for auditing"""
    cmd_str = ' '.join(cmd)
    
    log_entry = {
        "timestamp": datetime.datetime.now().isoformat(),
        "function": function_name,
        "command": cmd_str,
        "namespace": namespace,
        "success": success,
        "user": os.getenv("USER", "unknown"),
        "pwd": os.getcwd()
    }
    
    if error_msg:
        log_entry["error"] = error_msg
    
    if success:
        logger.info(f"KUBECTL_SUCCESS: {json.dumps(log_entry)}")
    else:
        logger.error(f"KUBECTL_ERROR: {json.dumps(log_entry)}")

def check_kubectl():
    """Check if kubectl is available and configured"""
    try:
        result = subprocess.run(["kubectl", "version", "--client"], 
                              capture_output=True, check=True)
        return True, "kubectl is available"
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False, "kubectl is not installed or not in PATH"

def interactive_kubernetes_assistant():
    """Interactive Kubernetes assistant that can run real kubectl commands"""
    
    # Set up logging
    logger = setup_logging()
    
    # Check if API key is set
    if not os.getenv("OPENAI_API_KEY"):
        print("‚ùå ERROR: OPENAI_API_KEY environment variable is not set")
        print("Please set your OpenAI API key: export OPENAI_API_KEY='your-api-key-here'")
        logger.error("OPENAI_API_KEY not set - exiting")
        return
    
    # Check kubectl availability
    kubectl_available, kubectl_msg = check_kubectl()
    if not kubectl_available:
        print(f"‚ùå {kubectl_msg}")
        print("Please install kubectl and configure it to connect to your cluster")
        logger.error(f"kubectl not available: {kubectl_msg}")
        return
    
    print("üöÄ Interactive Kubernetes Assistant")
    print("=" * 50)
    print(f"‚úÖ {kubectl_msg}")
    print("You can ask me about pods, logs, or any Kubernetes operations!")
    print("Type 'quit' to exit\n")
    logger.info("Interactive Kubernetes Assistant started successfully")
    
    # Initialize OpenAI client
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    
    # Define available functions
    functions = [
        {
            "name": "get_kubernetes_pods",
            "description": "Get information about pods in a Kubernetes namespace using kubectl",
            "parameters": {
                "type": "object",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The Kubernetes namespace to query (e.g., 'default', 'kube-system')"
                    },
                    "pod_status": {
                        "type": "string",
                        "description": "Filter pods by status. Leave empty for all pods.",
                        "enum": ["", "Running", "Pending", "CrashLoopBackOff", "Failed", "Succeeded"]
                    }
                },
                "required": ["namespace"]
            }
        },
        {
            "name": "get_pod_logs",
            "description": "Get logs from a specific Kubernetes pod using kubectl",
            "parameters": {
                "type": "object",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The Kubernetes namespace"
                    },
                    "pod_name": {
                        "type": "string", 
                        "description": "The name of the pod to get logs from"
                    },
                    "lines": {
                        "type": "integer",
                        "description": "Number of lines to retrieve (default: 50)",
                        "default": 50
                    }
                },
                "required": ["namespace", "pod_name"]
            }
        },
        {
            "name": "describe_pod",
            "description": "Get detailed information about a specific pod using kubectl describe",
            "parameters": {
                "type": "object",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The Kubernetes namespace"
                    },
                    "pod_name": {
                        "type": "string",
                        "description": "The name of the pod to describe"
                    }
                },
                "required": ["namespace", "pod_name"]
            }
        },
        {
            "name": "execute_kubectl_command",
            "description": "Execute any kubectl command. Use this as a fallback when other functions don't meet the user's needs. Always requires user confirmation for security.",
            "parameters": {
                "type": "object",
                "properties": {
                    "kubectl_args": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "The kubectl command arguments (e.g., ['get', 'namespaces'] or ['get', 'nodes', '-o', 'wide'])"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human-readable description of what this command will do"
                    }
                },
                "required": ["kubectl_args", "description"]
            }
        }
    ]
    
    # Function implementations
    def get_kubernetes_pods(namespace, pod_status=""):
        # Generated by Copilot
        try:
            cmd = ["kubectl", "get", "pods", "-n", namespace, "-o", "json"]
            log_kubectl_command(logger, cmd, namespace, function_name="get_kubernetes_pods")
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            # Return raw JSON output for the AI to interpret
            return f"kubectl get pods output for namespace '{namespace}':\n{result.stdout}"
            
        except subprocess.CalledProcessError as e:
            log_kubectl_command(logger, cmd, namespace, function_name="get_kubernetes_pods", success=False, error_msg=str(e.stderr))
            return f"‚ùå Error running kubectl: {e.stderr}"
        except Exception as e:
            log_kubectl_command(logger, cmd, namespace, function_name="get_kubernetes_pods", success=False, error_msg=str(e))
            return f"‚ùå Error: {str(e)}"
    
    def get_pod_logs(namespace, pod_name, lines=50):
        # Generated by Copilot
        try:
            cmd = ["kubectl", "logs", pod_name, "-n", namespace, "--tail", str(lines)]
            log_kubectl_command(logger, cmd, namespace, function_name="get_pod_logs")
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            return f"kubectl logs output for pod '{pod_name}' in namespace '{namespace}' (last {lines} lines):\n{result.stdout}"
            
        except subprocess.CalledProcessError as e:
            log_kubectl_command(logger, cmd, namespace, function_name="get_pod_logs", success=False, error_msg=str(e.stderr))
            return f"‚ùå Error running kubectl logs: {e.stderr}"
        except Exception as e:
            log_kubectl_command(logger, cmd, namespace, function_name="get_pod_logs", success=False, error_msg=str(e))
            return f"‚ùå Error: {str(e)}"
    
    def describe_pod(namespace, pod_name):
        # Generated by Copilot
        try:
            cmd = ["kubectl", "describe", "pod", pod_name, "-n", namespace]
            log_kubectl_command(logger, cmd, namespace, function_name="describe_pod")
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            return f"kubectl describe output for pod '{pod_name}' in namespace '{namespace}':\n{result.stdout}"
            
        except subprocess.CalledProcessError as e:
            log_kubectl_command(logger, cmd, namespace, function_name="describe_pod", success=False, error_msg=str(e.stderr))
            return f"‚ùå Error running kubectl describe: {e.stderr}"
        except Exception as e:
            log_kubectl_command(logger, cmd, namespace, function_name="describe_pod", success=False, error_msg=str(e))
            return f"‚ùå Error: {str(e)}"
    
    def execute_kubectl_command(kubectl_args, description):
        # Generated by Copilot
        try:
            cmd = ["kubectl"] + kubectl_args
            cmd_str = ' '.join(cmd)
            
            print(f"\n‚ö†Ô∏è  SECURITY CONFIRMATION REQUIRED")
            print(f"üìã Command: {cmd_str}")
            print(f"üìù Description: {description}")
            confirmation = input("üîê Do you want to execute this command? [Y/n] (Enter = Yes): ").strip().lower()
            
            # Log the confirmation request
            logger.info(f"KUBECTL_CONFIRMATION_REQUESTED: {json.dumps({'command': cmd_str, 'description': description, 'user': os.getenv('USER', 'unknown')})}")
            
            if confirmation in ['n', 'no']:
                logger.info(f"KUBECTL_DENIED: {json.dumps({'command': cmd_str, 'user': os.getenv('USER', 'unknown')})}")
                return f"‚ùå Command execution denied by user: {cmd_str}"
            
            # Log approval
            logger.info(f"KUBECTL_APPROVED: {json.dumps({'command': cmd_str, 'user': os.getenv('USER', 'unknown')})}")
            
            # Execute the command
            log_kubectl_command(logger, cmd, function_name="execute_kubectl_command")
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            return f"kubectl command output:\nCommand: {cmd_str}\n\n{result.stdout}"
            
        except subprocess.CalledProcessError as e:
            log_kubectl_command(logger, cmd, function_name="execute_kubectl_command", success=False, error_msg=str(e.stderr))
            return f"‚ùå Error running kubectl command: {e.stderr}"
        except Exception as e:
            log_kubectl_command(logger, cmd, function_name="execute_kubectl_command", success=False, error_msg=str(e))
            return f"‚ùå Error: {str(e)}"
    
    # Function mapping
    function_map = {
        "get_kubernetes_pods": get_kubernetes_pods,
        "get_pod_logs": get_pod_logs,
        "describe_pod": describe_pod,
        "execute_kubectl_command": execute_kubectl_command
    }
    
    # Generated by Copilot - Initialize conversation history
    conversation_history = [
        {"role": "system", "content": "You are a helpful DevOps assistant that can interact with Kubernetes clusters using kubectl commands. You can get pod information, logs, and descriptions. Always be helpful and provide clear explanations. Remember previous interactions in this conversation to provide better context."}
    ]
    
    # Interactive loop
    while True:
        try:
            user_input = input("\nü§î What would you like to know about your Kubernetes cluster? ")
            
            if user_input.lower() in ['quit', 'exit', 'q']:
                print("üëã Goodbye!")
                logger.info("=== Kubernetes Assistant Session Ended ===")
                break
            
            if not user_input.strip():
                continue
            
            # Log user input for auditing
            logger.info(f"USER_INPUT: {user_input}")
            
            # Add user input to conversation history
            conversation_history.append({"role": "user", "content": user_input})
            
            # Call OpenAI API with full conversation history
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=conversation_history,
                tools=[{"type": "function", "function": func} for func in functions],
                tool_choice="auto"
            )
            
            message = response.choices[0].message
            
            # Check for tool calls
            if message.tool_calls:
                print(f"\nüîß Running kubectl commands... ({len(message.tool_calls)} function{'s' if len(message.tool_calls) > 1 else ''} to execute)")
                
                # Add assistant response with tool calls to history
                conversation_history.append({
                    "role": "assistant", 
                    "content": message.content, 
                    "tool_calls": message.tool_calls
                })
                
                # Check if any tool calls require confirmation (execute_kubectl_command)
                confirmation_required = any(tc.function.name == "execute_kubectl_command" for tc in message.tool_calls)
                if confirmation_required and len(message.tool_calls) > 1:
                    print("‚ö†Ô∏è  Note: One or more commands require your confirmation before execution.")
                
                # Execute each tool call and add results to history
                for i, tool_call in enumerate(message.tool_calls):
                    function_name = tool_call.function.name
                    args = json.loads(tool_call.function.arguments)
                    
                    if len(message.tool_calls) > 1:
                        print(f"\nüìã Executing function {i+1}/{len(message.tool_calls)}: {function_name}")
                    
                    if function_name in function_map:
                        output = function_map[function_name](**args)
                        conversation_history.append({
                            "role": "tool",
                            "tool_call_id": tool_call.id,
                            "content": output
                        })
                        
                        # If command was denied by user, note it
                        if "Command execution denied by user" in output:
                            print(f"‚è≠Ô∏è  Skipping denied command, continuing with remaining functions...")
                    else:
                        error_msg = f"‚ùå Unknown function: {function_name}"
                        print(error_msg)
                        conversation_history.append({
                            "role": "tool",
                            "tool_call_id": tool_call.id,
                            "content": error_msg
                        })
                        logger.error(f"UNKNOWN_FUNCTION: {function_name}")
                
                print(f"\n‚úÖ Completed {len(message.tool_calls)} function call{'s' if len(message.tool_calls) > 1 else ''}")
                
                # Get final response with full context
                follow_up = client.chat.completions.create(
                    model="gpt-4o",
                    messages=conversation_history
                )
                
                final_response = follow_up.choices[0].message.content
                print("\n‚úÖ Response:")
                print(final_response)
                
                # Add final response to conversation history
                conversation_history.append({
                    "role": "assistant",
                    "content": final_response
                })
                
            else:
                response_content = message.content
                print(f"\nü§ñ {response_content}")
                
                # Add assistant response to conversation history
                conversation_history.append({
                    "role": "assistant",
                    "content": response_content
                })
                
        except KeyboardInterrupt:
            print("\nüëã Goodbye!")
            logger.info("=== Session interrupted by user (Ctrl+C) ===")
            break
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
            logger.error(f"GENERAL_ERROR: {str(e)}")

if __name__ == "__main__":
    interactive_kubernetes_assistant()
