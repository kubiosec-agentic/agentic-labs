from __future__ import annotations
import os
import asyncio
import warnings
from dataclasses import dataclass

# Suppress deprecation warning from agents library
warnings.filterwarnings("ignore", category=DeprecationWarning, message="There is no current event loop")

from mem0 import Memory
from agents import (
    Agent,
    Runner,
    function_tool,
    RunContextWrapper,
    ItemHelpers,
    MessageOutputItem,
    ToolCallItem,
    ToolCallOutputItem,
)

# --- Simple context that carries a user_id for scoping memories
@dataclass
class Mem0Context:
    user_id: str = "demo-user"

# --- Mem0 client (self-hosted config with Qdrant)
config = {
    "vector_store": {
        "provider": "qdrant",
        "config": {
            "host": "localhost",
            "port": 6333,
            "collection_name": "mem0",
        }
    },
    "llm": {
        "provider": "openai_structured",
        "config": {"model": "gpt-4o-2024-08-06", "temperature": 0.0}
    }
}

MEM0 = Memory.from_config(config)

# --- Tools the agent can call
@function_tool
def add_to_memory(ctx: RunContextWrapper[Mem0Context], content: str) -> str:
    """Store a fact in Mem0."""
    uid = ctx.context.user_id
    messages = [{"role": "user", "content": content}]
    resp = MEM0.add(messages, user_id=uid)
    return f"Saved {len(resp) if isinstance(resp, list) else 1} item(s)."

@function_tool
def search_memory(ctx: RunContextWrapper[Mem0Context], query: str) -> str:
    """Search facts in Mem0 relevant to the query."""
    uid = ctx.context.user_id
    res = MEM0.search(query, user_id=uid)
    items = res if isinstance(res, list) else res.get("results", [])
    memories = [it.get("memory", str(it)) for it in items]
    return "\n".join(memories) if memories else "(no matches)"

@function_tool
def get_all_memory(ctx: RunContextWrapper[Mem0Context]) -> str:
    """Return all stored facts for this user."""
    uid = ctx.context.user_id
    res = MEM0.get_all(user_id=uid)
    items = res if isinstance(res, list) else res.get("results", [])
    memories = [it.get("memory", str(it)) for it in items]
    return "\n".join(memories) if memories else "(empty)"

# --- The agent
memory_agent = Agent[Mem0Context](
    name="Memory Assistant",
    instructions = (
        "You have access to three memory tools:\n"
        "- **add_to_memory**: Use when the user says 'remember' or shares a personal/profile fact.\n"
        "- **search_memory**: Use when the user asks about something they told you before.\n"
        "- **get_all_memory**: Use when the user asks what you know about them.\n\n"
        "Always call the appropriate tool first, then provide a concise natural-language response to the user.\n"
        "Create a concise profile of the user based on what they tell you.\n"
        "Always update the profile when they tell you something new.\n"
    ),

    tools=[add_to_memory, search_memory, get_all_memory],
)

if __name__ == "__main__":
    async def main():
        # Simple usage
        ctx = Mem0Context(user_id="demo-user")
        
        # Run the agent with your prompt
        result = await Runner.run(memory_agent, "My name is Philippe. Store it", context=ctx)
        
        # Print what happened
        for item in result.new_items:
            if isinstance(item, MessageOutputItem):
                print("Assistant:", ItemHelpers.text_message_output(item))
            elif isinstance(item, ToolCallItem):
                print("Tool called:", item.raw_item.name if hasattr(item.raw_item, 'name') else 'unknown')
            elif isinstance(item, ToolCallOutputItem):
                print("Tool result:", item.output)
    
    # Generated by Copilot
    asyncio.run(main())


